
// use treedefs::{L_CODES, D_CODES, DIST_CODE_LEN, MAX_MATCH, MIN_MATCH, LENGTH_CODES};
// use treedefs::{extra_lbits, extra_dbits};
use std::iter::range_inclusive;
use treedefs::*;

// This contains all of the static lookup tables used by ZLIB.
// Some of them are hand-written, and some are generated by code.
pub struct StaticTrees
{
    // The static literal tree. Since the bit lengths are imposed, there is no
    // need for the L_CODES extra codes used during heap construction. However
    // The codes 286 and 287 are needed to build a canonical tree (see _tr_init
    // below).
    pub static_ltree_lengths :[u8, ..L_CODES+2],
    pub static_ltree_codes :[u16, ..L_CODES+2],

    // The static distance tree. (Actually a trivial tree since all codes use 5 bits.)
    pub static_dtree_lengths :[u8, ..D_CODES],
    pub static_dtree_codes :[u16, ..D_CODES],

    // Distance codes. The first 256 values correspond to the distances
    // 3 .. 258, the last 256 values correspond to the top 8 bits of
    // the 15 bit distances.
    pub dist_code: [u8, ..DIST_CODE_LEN],

    // length code for each normalized match length (0 == MIN_MATCH)
    pub length_code :[u8, ..MAX_MATCH - MIN_MATCH + 1],

    // First normalized length for each code (0 = MIN_MATCH)
    pub base_length :[u8, ..LENGTH_CODES],

    // First normalized distance for each code (0 = distance of 1)
    pub base_dist: [u16, ..D_CODES],
}

// ===========================================================================
// Initialize the various 'constant' tables.
//
// Note: Ideally, we would execute this at compile time, not runtime.
//
pub fn tr_static_init() -> StaticTrees
{
    // int n;        /* iterates over tree elements */
    // int bits;     /* bit counter */
    // int length;   /* length value */
    // int code;     /* code value */
    // int dist;     /* distance index */

    /* Initialize the mapping length (0..255) . length code (0..28) */
    let mut length :uint = 0;
    let mut base_length :[u8, ..LENGTH_CODES] = [0, ..LENGTH_CODES];
    let mut length_code :[u8, ..MAX_MATCH-MIN_MATCH+1] = [0, ..MAX_MATCH-MIN_MATCH+1];
    for code in range(0, LENGTH_CODES-1) {
        base_length[code] = length as u8;
        for _ in range(0, 1u32 << EXTRA_LBITS[code] as uint) {
            length_code[length] = code as u8;
            length += 1;
        }
    }
    assert!(length == 256);
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    length_code[255] = (LENGTH_CODES - 1) as u8;

    let mut base_dist = [0u16, ..D_CODES];

    /* Initialize the mapping dist (0..32K) . dist code (0..29) */
    let mut dist :u16 = 0;
    let mut dist_code = [0u8, ..DIST_CODE_LEN];
    for code in range(0, 16) {
        base_dist[code] = dist;
        for _ in range(0, 1u32 << EXTRA_DBITS[code] as uint) {
            dist_code[dist as uint] = code as u8;
            dist += 1;
        }
    }
    assert!(dist == 256);

    dist >>= 7; /* from now on, all distances are divided by 128 */
    for code in range(16, D_CODES) {
        base_dist[code] = dist << 7;
        for _ in range(0, 1u32 << (EXTRA_DBITS[code] as uint - 7)) {
            dist_code[256] = code as u8;
            dist += 1;
        }
    }
    assert!(dist == 256);

    /* Construct the codes of the static literal tree */

    // The static literal tree. Since the bit lengths are imposed, there is no
    // need for the L_CODES extra codes used during heap construction. However
    // The codes 286 and 287 are needed to build a canonical tree (see _tr_init
    // below).
    // let mut static_ltree :[ct_data, ..L_CODES+2] = [ct_data{fc: 0, dl: 0}, ..L_CODES+2];

    let mut static_ltree_lengths = [0u8, ..L_CODES + 2];

    /* number of codes at each bit length for an optimal tree */
    let mut bl_count = [0u16, ..MAX_BITS+1];
    let mut n :uint = 0;
    while n <= 143 { static_ltree_lengths[n] = 8; n += 1; bl_count[8] += 1; }
    while n <= 255 { static_ltree_lengths[n] = 9; n += 1; bl_count[9] += 1; }
    while n <= 279 { static_ltree_lengths[n] = 7; n += 1; bl_count[7] += 1; }
    while n <= 287 { static_ltree_lengths[n] = 8; n += 1; bl_count[8] += 1; }
    // Codes 286 and 287 do not exist, but we must include them in the
    // tree construction to get a canonical Huffman tree (longest code
    // all ones)
    let mut static_ltree_codes :[u16, ..L_CODES + 2] = [0, ..L_CODES + 2];
    gen_codes(&static_ltree_lengths, static_ltree_codes.as_mut_slice(), L_CODES + 1, bl_count.as_slice());

    // Generate static_dtree
    /* The static distance tree is trivial: */
    // let mut static_dtree : [ct_data, ..D_CODES] = [ct_data{fc: 0, dl: 0}, ..D_CODES];
    let mut static_dtree_lengths = [0u8, ..D_CODES];
    let mut static_dtree_codes = [0u16, ..D_CODES];
    for n in range(0, D_CODES) {
        static_dtree_lengths[n] = 5;
        static_dtree_codes[n] = bi_reverse(n as u32, 5) as u16;
    }


    StaticTrees {
        base_length: base_length,
        length_code: length_code,

        base_dist: base_dist,

        static_ltree_lengths: static_ltree_lengths,
        static_ltree_codes: static_ltree_codes,

        static_dtree_lengths: static_dtree_lengths,
        static_dtree_codes: static_dtree_codes,
    
        dist_code: dist_code,
    }
}

// ===========================================================================
// Generate the codes for a given tree and bit counts (which need not be
// optimal).
// IN assertion: the array bl_count contains the bit length statistics for
// the given tree and the field len is set for all tree elements.
// OUT assertion: the field code is set for all tree elements of non
//     zero code length.
//
pub fn gen_codes(
    // tree :&mut [ct_data],                    // the tree to decorate
    lens :&[u8],                                // the input lengths
    codes :&mut [u16],                          // the output codes
    max_code: uint,                             // largest code with non zero frequency
    bl_count: &[u16])                           // number of codes at each bit length
{
    assert!(lens.len() == codes.len());

    let mut next_code = [0u16, ..MAX_BITS+1];     // next code value for each bit length
    let mut code :u16 = 0;                      // running code value

    // The distribution counts are first used to generate the code values
    // without bit reversal.
    for bits in range_inclusive(1, MAX_BITS) {
        println!("gen_codes: bits = {}", bits);
        code = (code + bl_count[bits - 1]) << 1;
        next_code[bits] = code;
        println!("next_code[{}] = {}", bits, code);
    }

    // Check that the bit counts in bl_count are consistent. The last code
    // must be all ones.
    assert!(code + bl_count[MAX_BITS]-1 == (1 << MAX_BITS) - 1, "inconsistent bit counts");
    println!("gen_codes: max_code {}", max_code);

    // n is code index
    for n in range(0, max_code + 1) {
        let len = lens[n];
        if len == 0 {
            continue;
        }

        /* Now reverse the bits */
        codes[n] = bi_reverse(next_code[len as uint] as u32, len as uint) as u16;
        next_code[len as uint] += 1;

        // println!("n %3d %c l %2d c %4x (%x) ", n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1);
    }
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
fn bi_reverse(
    code :u32,  /* the value to invert */
    len: uint)  /* its bit length */
    -> u32
{
    let mut c = code;
    let mut res :u32 = 0;    
    let mut mlen = len;
    loop {
        res |= c & 1;
        c >>= 1;
        res <<= 1;
        mlen -= 1;
        if mlen == 0 {
            break;
        }
    }
    return res >> 1;
}

